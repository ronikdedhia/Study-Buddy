{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport invariant from 'invariant';\nimport { CameraType, ImageType } from \"./Camera.types\";\nimport * as CapabilityUtils from \"./WebCapabilityUtils\";\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from \"./WebConstants\";\nimport { requestUserMediaAsync } from \"./WebUserMediaManager\";\nexport function getImageSize(videoWidth, videoHeight, scale) {\n  var width = videoWidth * scale;\n  var ratio = videoWidth / width;\n  var height = videoHeight / ratio;\n  return {\n    width: width,\n    height: height\n  };\n}\nexport function toDataURL(canvas, imageType, quality) {\n  invariant(Object.values(ImageType).includes(imageType), \"expo-camera: \" + imageType + \" is not a valid ImageType. Expected a string from: \" + Object.values(ImageType).join(', '));\n  var format = ImageTypeFormat[imageType];\n  if (imageType === ImageType.jpg) {\n    invariant(quality <= 1 && quality >= 0, \"expo-camera: \" + quality + \" is not a valid image quality. Expected a number from 0...1\");\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\nexport function hasValidConstraints(preferredCameraType, width, height) {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\nfunction ensureCameraPictureOptions(config) {\n  var captureOptions = {\n    scale: 1,\n    imageType: ImageType.png,\n    isImageMirror: false\n  };\n  for (var key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n  return captureOptions;\n}\nvar DEFAULT_QUALITY = 0.92;\nexport function captureImageData(video) {\n  var pictureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n  var canvas = captureImageContext(video, pictureOptions);\n  var context = canvas.getContext('2d', {\n    alpha: false\n  });\n  if (!context || !canvas.width || !canvas.height) {\n    return null;\n  }\n  var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  return imageData;\n}\nexport function captureImageContext(video, _ref) {\n  var _ref$scale = _ref.scale,\n    scale = _ref$scale === void 0 ? 1 : _ref$scale,\n    _ref$isImageMirror = _ref.isImageMirror,\n    isImageMirror = _ref$isImageMirror === void 0 ? false : _ref$isImageMirror;\n  var videoWidth = video.videoWidth,\n    videoHeight = video.videoHeight;\n  var _getImageSize = getImageSize(videoWidth, videoHeight, scale),\n    width = _getImageSize.width,\n    height = _getImageSize.height;\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  var context = canvas.getContext('2d', {\n    alpha: false\n  });\n  if (!context) {\n    throw new Error('Context is not defined');\n  }\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n  context.drawImage(video, 0, 0, width, height);\n  return canvas;\n}\nexport function captureImage(video, pictureOptions) {\n  var config = ensureCameraPictureOptions(pictureOptions);\n  var canvas = captureImageContext(video, config);\n  var imageType = config.imageType,\n    _config$quality = config.quality,\n    quality = _config$quality === void 0 ? DEFAULT_QUALITY : _config$quality;\n  return toDataURL(canvas, imageType, quality);\n}\nfunction getSupportedConstraints() {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n  return null;\n}\nexport function getIdealConstraints(preferredCameraType, width, height) {\n  var preferredConstraints = {\n    audio: false,\n    video: {}\n  };\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n  var supports = getSupportedConstraints();\n  if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n  if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n    var facingMode = CameraTypeToFacingMode[preferredCameraType];\n    if (isWebKit()) {\n      var key = facingMode === 'user' ? 'exact' : 'ideal';\n      preferredConstraints.video.facingMode = _defineProperty({}, key, facingMode);\n    } else {\n      preferredConstraints.video.facingMode = {\n        ideal: CameraTypeToFacingMode[preferredCameraType]\n      };\n    }\n  }\n  if (isMediaTrackConstraints(preferredConstraints.video)) {\n    preferredConstraints.video.width = width;\n    preferredConstraints.video.height = height;\n  }\n  return preferredConstraints;\n}\nfunction isMediaTrackConstraints(input) {\n  return input && typeof input.video !== 'boolean';\n}\nexport function getPreferredStreamDevice(_x, _x2, _x3) {\n  return _getPreferredStreamDevice.apply(this, arguments);\n}\nfunction _getPreferredStreamDevice() {\n  _getPreferredStreamDevice = _asyncToGenerator(function* (preferredCameraType, preferredWidth, preferredHeight) {\n    try {\n      return yield getStreamDevice(preferredCameraType, preferredWidth, preferredHeight);\n    } catch (error) {\n      if (error instanceof OverconstrainedError && error.constraint === 'facingMode') {\n        var nextCameraType = preferredCameraType === CameraType.back ? CameraType.front : CameraType.back;\n        return yield getStreamDevice(nextCameraType, preferredWidth, preferredHeight);\n      }\n      throw error;\n    }\n  });\n  return _getPreferredStreamDevice.apply(this, arguments);\n}\nexport function getStreamDevice(_x4, _x5, _x6) {\n  return _getStreamDevice.apply(this, arguments);\n}\nfunction _getStreamDevice() {\n  _getStreamDevice = _asyncToGenerator(function* (preferredCameraType, preferredWidth, preferredHeight) {\n    var constraints = getIdealConstraints(preferredCameraType, preferredWidth, preferredHeight);\n    var stream = yield requestUserMediaAsync(constraints);\n    return stream;\n  });\n  return _getStreamDevice.apply(this, arguments);\n}\nexport function isWebKit() {\n  return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\nexport function compareStreams(a, b) {\n  if (!a || !b) {\n    return false;\n  }\n  var settingsA = a.getTracks()[0].getSettings();\n  var settingsB = b.getTracks()[0].getSettings();\n  return settingsA.deviceId === settingsB.deviceId;\n}\nexport function capture(video, settings, config) {\n  var base64 = captureImage(video, config);\n  var capturedPicture = {\n    uri: base64,\n    base64: base64,\n    width: 0,\n    height: 0\n  };\n  if (settings) {\n    var _settings$width = settings.width,\n      width = _settings$width === void 0 ? 0 : _settings$width,\n      _settings$height = settings.height,\n      height = _settings$height === void 0 ? 0 : _settings$height;\n    capturedPicture.width = width;\n    capturedPicture.height = height;\n    capturedPicture.exif = settings;\n  }\n  if (config.onPictureSaved) {\n    config.onPictureSaved(capturedPicture);\n  }\n  return capturedPicture;\n}\nexport function syncTrackCapabilities(_x7, _x8) {\n  return _syncTrackCapabilities.apply(this, arguments);\n}\nfunction _syncTrackCapabilities() {\n  _syncTrackCapabilities = _asyncToGenerator(function* (cameraType, stream) {\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (stream != null && stream.getVideoTracks) {\n      yield Promise.all(stream.getVideoTracks().map(function (track) {\n        return onCapabilitiesReady(cameraType, track, settings);\n      }));\n    }\n  });\n  return _syncTrackCapabilities.apply(this, arguments);\n}\nfunction onCapabilitiesReady(_x9, _x10) {\n  return _onCapabilitiesReady.apply(this, arguments);\n}\nfunction _onCapabilitiesReady() {\n  _onCapabilitiesReady = _asyncToGenerator(function* (cameraType, track) {\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var capabilities = track.getCapabilities();\n    var constraints = {};\n    var clampedValues = ['exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'zoom'];\n    for (var property of clampedValues) {\n      if (capabilities[property]) {\n        constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n      }\n    }\n    function validatedInternalConstrainedValue(constraintKey, settingsKey, converter) {\n      var convertedSetting = converter(settings[settingsKey]);\n      return validatedConstrainedValue({\n        constraintKey: constraintKey,\n        settingsKey: settingsKey,\n        convertedSetting: convertedSetting,\n        capabilities: capabilities,\n        settings: settings,\n        cameraType: cameraType\n      });\n    }\n    if (capabilities.focusMode && settings.autoFocus !== undefined) {\n      constraints.focusMode = validatedInternalConstrainedValue('focusMode', 'autoFocus', CapabilityUtils.convertAutoFocusJSONToNative);\n    }\n    if (capabilities.torch && settings.flashMode !== undefined) {\n      constraints.torch = validatedInternalConstrainedValue('torch', 'flashMode', CapabilityUtils.convertFlashModeJSONToNative);\n    }\n    if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n      constraints.whiteBalanceMode = validatedInternalConstrainedValue('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n    }\n    try {\n      yield track.applyConstraints({\n        advanced: [constraints]\n      });\n    } catch (error) {\n      if (__DEV__) console.warn('Failed to apply constraints', error);\n    }\n  });\n  return _onCapabilitiesReady.apply(this, arguments);\n}\nexport function stopMediaStream(stream) {\n  if (!stream) {\n    return;\n  }\n  if (stream.getAudioTracks) {\n    stream.getAudioTracks().forEach(function (track) {\n      return track.stop();\n    });\n  }\n  if (stream.getVideoTracks) {\n    stream.getVideoTracks().forEach(function (track) {\n      return track.stop();\n    });\n  }\n  if (isMediaStreamTrack(stream)) {\n    stream.stop();\n  }\n}\nexport function setVideoSource(video, stream) {\n  var _window$URL$createObj;\n  var createObjectURL = (_window$URL$createObj = window.URL.createObjectURL) != null ? _window$URL$createObj : window.webkitURL.createObjectURL;\n  if (typeof video.srcObject !== 'undefined') {\n    video.srcObject = stream;\n  } else if (typeof video.mozSrcObject !== 'undefined') {\n    video.mozSrcObject = stream;\n  } else if (stream && createObjectURL) {\n    video.src = createObjectURL(stream);\n  }\n  if (!stream) {\n    var _window$URL$revokeObj, _ref2, _video$src;\n    var revokeObjectURL = (_window$URL$revokeObj = window.URL.revokeObjectURL) != null ? _window$URL$revokeObj : window.webkitURL.revokeObjectURL;\n    var source = (_ref2 = (_video$src = video.src) != null ? _video$src : video.srcObject) != null ? _ref2 : video.mozSrcObject;\n    if (revokeObjectURL && typeof source === 'string') {\n      revokeObjectURL(source);\n    }\n  }\n}\nexport function isCapabilityAvailable(video, keyName) {\n  var stream = video.srcObject;\n  if (stream instanceof MediaStream) {\n    var _videoTrack$getCapabi;\n    var videoTrack = stream.getVideoTracks()[0];\n    return videoTrack.getCapabilities == null ? void 0 : (_videoTrack$getCapabi = videoTrack.getCapabilities()) == null ? void 0 : _videoTrack$getCapabi[keyName];\n  }\n  return false;\n}\nfunction isMediaStreamTrack(input) {\n  return typeof input.stop === 'function';\n}\nfunction convertNormalizedSetting(range, value) {\n  if (!value) {\n    return;\n  }\n  var converted = convertRange(value, [range.min, range.max]);\n  return Math.min(range.max, Math.max(range.min, converted));\n}\nfunction convertRange(value, r2) {\n  var r1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 1];\n  return (value - r1[0]) * (r2[1] - r2[0]) / (r1[1] - r1[0]) + r2[0];\n}\nfunction validatedConstrainedValue(props) {\n  var constraintKey = props.constraintKey,\n    settingsKey = props.settingsKey,\n    convertedSetting = props.convertedSetting,\n    capabilities = props.capabilities,\n    settings = props.settings,\n    cameraType = props.cameraType;\n  var setting = settings[settingsKey];\n  if (Array.isArray(capabilities[constraintKey]) && convertedSetting && !capabilities[constraintKey].includes(convertedSetting)) {\n    if (__DEV__) {\n      console.warn(\" { \" + settingsKey + \": \\\"\" + setting + \"\\\" } (converted to \\\"\" + convertedSetting + \"\\\" in the browser) is not supported for camera type \\\"\" + cameraType + \"\\\" in your browser. Using the default value instead.\");\n    }\n    return undefined;\n  }\n  return convertedSetting;\n}","map":{"version":3,"sources":["../src/WebCameraUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-env browser */\nimport invariant from 'invariant';\n\nimport {\n  CameraType,\n  CameraCapturedPicture,\n  ImageSize,\n  ImageType,\n  WebCameraSettings,\n  CameraPictureOptions,\n} from './Camera.types';\nimport * as CapabilityUtils from './WebCapabilityUtils';\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from './WebConstants';\nimport { requestUserMediaAsync } from './WebUserMediaManager';\n\ninterface ConstrainLongRange {\n  max?: number;\n  min?: number;\n  exact?: number;\n  ideal?: number;\n}\n\nexport function getImageSize(videoWidth: number, videoHeight: number, scale: number): ImageSize {\n  const width = videoWidth * scale;\n  const ratio = videoWidth / width;\n  const height = videoHeight / ratio;\n\n  return {\n    width,\n    height,\n  };\n}\n\nexport function toDataURL(\n  canvas: HTMLCanvasElement,\n  imageType: ImageType,\n  quality: number\n): string {\n  invariant(\n    Object.values(ImageType).includes(imageType),\n    `expo-camera: ${imageType} is not a valid ImageType. Expected a string from: ${Object.values(\n      ImageType\n    ).join(', ')}`\n  );\n\n  const format = ImageTypeFormat[imageType];\n  if (imageType === ImageType.jpg) {\n    invariant(\n      quality <= 1 && quality >= 0,\n      `expo-camera: ${quality} is not a valid image quality. Expected a number from 0...1`\n    );\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\n\nexport function hasValidConstraints(\n  preferredCameraType?: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): boolean {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\n\nfunction ensureCameraPictureOptions(config: CameraPictureOptions): CameraPictureOptions {\n  const captureOptions = {\n    scale: 1,\n    imageType: ImageType.png,\n    isImageMirror: false,\n  };\n\n  for (const key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n  return captureOptions;\n}\n\nconst DEFAULT_QUALITY = 0.92;\n\nexport function captureImageData(\n  video: HTMLVideoElement | null,\n  pictureOptions: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'> = {}\n): ImageData | null {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n  const canvas = captureImageContext(video, pictureOptions);\n\n  const context = canvas.getContext('2d', { alpha: false });\n  if (!context || !canvas.width || !canvas.height) {\n    return null;\n  }\n\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  return imageData;\n}\n\nexport function captureImageContext(\n  video: HTMLVideoElement,\n  { scale = 1, isImageMirror = false }: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'>\n): HTMLCanvasElement {\n  const { videoWidth, videoHeight } = video;\n  const { width, height } = getImageSize(videoWidth, videoHeight, scale!);\n\n  // Build the canvas size and draw the camera image to the context from video\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d', { alpha: false });\n\n  if (!context) {\n    // Should never be called\n    throw new Error('Context is not defined');\n  }\n  // sharp image details\n  // context.imageSmoothingEnabled = false;\n\n  // Flip horizontally (as css transform: rotateY(180deg))\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n\n  context.drawImage(video, 0, 0, width, height);\n\n  return canvas;\n}\n\nexport function captureImage(\n  video: HTMLVideoElement,\n  pictureOptions: CameraPictureOptions\n): string {\n  const config = ensureCameraPictureOptions(pictureOptions);\n  const canvas = captureImageContext(video, config);\n  const { imageType, quality = DEFAULT_QUALITY } = config;\n  return toDataURL(canvas, imageType!, quality);\n}\n\nfunction getSupportedConstraints(): MediaTrackSupportedConstraints | null {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n  return null;\n}\n\nexport function getIdealConstraints(\n  preferredCameraType: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): MediaStreamConstraints {\n  const preferredConstraints: MediaStreamConstraints = {\n    audio: false,\n    video: {},\n  };\n\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n\n  const supports = getSupportedConstraints();\n  // TODO(Bacon): Test this\n  if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n\n  if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n    const facingMode = CameraTypeToFacingMode[preferredCameraType];\n    if (isWebKit()) {\n      const key = facingMode === 'user' ? 'exact' : 'ideal';\n      (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n        [key]: facingMode,\n      };\n    } else {\n      (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n        ideal: CameraTypeToFacingMode[preferredCameraType],\n      };\n    }\n  }\n\n  if (isMediaTrackConstraints(preferredConstraints.video)) {\n    preferredConstraints.video.width = width;\n    preferredConstraints.video.height = height;\n  }\n\n  return preferredConstraints;\n}\n\nfunction isMediaTrackConstraints(input: any): input is MediaTrackConstraints {\n  return input && typeof input.video !== 'boolean';\n}\n\n/**\n * Invoke getStreamDevice a second time with the opposing camera type if the preferred type cannot be retrieved.\n *\n * @param preferredCameraType\n * @param preferredWidth\n * @param preferredHeight\n */\nexport async function getPreferredStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  try {\n    return await getStreamDevice(preferredCameraType, preferredWidth, preferredHeight);\n  } catch (error) {\n    // A hack on desktop browsers to ensure any camera is used.\n    // eslint-disable-next-line no-undef\n    if (error instanceof OverconstrainedError && error.constraint === 'facingMode') {\n      const nextCameraType =\n        preferredCameraType === CameraType.back ? CameraType.front : CameraType.back;\n      return await getStreamDevice(nextCameraType, preferredWidth, preferredHeight);\n    }\n    throw error;\n  }\n}\n\nexport async function getStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = getIdealConstraints(\n    preferredCameraType,\n    preferredWidth,\n    preferredHeight\n  );\n  const stream: MediaStream = await requestUserMediaAsync(constraints);\n  return stream;\n}\n\nexport function isWebKit(): boolean {\n  return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\n\nexport function compareStreams(a: MediaStream | null, b: MediaStream | null): boolean {\n  if (!a || !b) {\n    return false;\n  }\n  const settingsA = a.getTracks()[0].getSettings();\n  const settingsB = b.getTracks()[0].getSettings();\n  return settingsA.deviceId === settingsB.deviceId;\n}\n\nexport function capture(\n  video: HTMLVideoElement,\n  settings: MediaTrackSettings,\n  config: CameraPictureOptions\n): CameraCapturedPicture {\n  const base64 = captureImage(video, config);\n\n  const capturedPicture: CameraCapturedPicture = {\n    uri: base64,\n    base64,\n    width: 0,\n    height: 0,\n  };\n\n  if (settings) {\n    const { width = 0, height = 0 } = settings;\n    capturedPicture.width = width;\n    capturedPicture.height = height;\n    capturedPicture.exif = settings;\n  }\n\n  if (config.onPictureSaved) {\n    config.onPictureSaved(capturedPicture);\n  }\n  return capturedPicture;\n}\n\nexport async function syncTrackCapabilities(\n  cameraType: CameraType,\n  stream: MediaStream | null,\n  settings: WebCameraSettings = {}\n): Promise<void> {\n  if (stream?.getVideoTracks) {\n    await Promise.all(\n      stream.getVideoTracks().map((track) => onCapabilitiesReady(cameraType, track, settings))\n    );\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\nasync function onCapabilitiesReady(\n  cameraType: CameraType,\n  track: MediaStreamTrack,\n  settings: WebCameraSettings = {}\n): Promise<void> {\n  const capabilities = track.getCapabilities();\n\n  // Create an empty object because if you set a constraint that isn't available an error will be thrown.\n  const constraints: MediaTrackConstraintSet = {};\n\n  // TODO(Bacon): Add `pointsOfInterest` support\n  const clampedValues = [\n    'exposureCompensation',\n    'colorTemperature',\n    'iso',\n    'brightness',\n    'contrast',\n    'saturation',\n    'sharpness',\n    'focusDistance',\n    'zoom',\n  ];\n\n  for (const property of clampedValues) {\n    if (capabilities[property]) {\n      constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n    }\n  }\n\n  function validatedInternalConstrainedValue<IConvertedType>(\n    constraintKey: string,\n    settingsKey: string,\n    converter: (settingValue: any) => IConvertedType\n  ) {\n    const convertedSetting = converter(settings[settingsKey]);\n    return validatedConstrainedValue({\n      constraintKey,\n      settingsKey,\n      convertedSetting,\n      capabilities,\n      settings,\n      cameraType,\n    });\n  }\n\n  if (capabilities.focusMode && settings.autoFocus !== undefined) {\n    constraints.focusMode = validatedInternalConstrainedValue<MediaTrackConstraintSet['focusMode']>(\n      'focusMode',\n      'autoFocus',\n      CapabilityUtils.convertAutoFocusJSONToNative\n    );\n  }\n\n  if (capabilities.torch && settings.flashMode !== undefined) {\n    constraints.torch = validatedInternalConstrainedValue<MediaTrackConstraintSet['torch']>(\n      'torch',\n      'flashMode',\n      CapabilityUtils.convertFlashModeJSONToNative\n    );\n  }\n\n  if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n    constraints.whiteBalanceMode = validatedInternalConstrainedValue<\n      MediaTrackConstraintSet['whiteBalanceMode']\n    >('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n  }\n\n  try {\n    await track.applyConstraints({ advanced: [constraints] });\n  } catch (error) {\n    if (__DEV__) console.warn('Failed to apply constraints', error);\n  }\n}\n\nexport function stopMediaStream(stream: MediaStream | null) {\n  if (!stream) {\n    return;\n  }\n  if (stream.getAudioTracks) {\n    stream.getAudioTracks().forEach((track) => track.stop());\n  }\n  if (stream.getVideoTracks) {\n    stream.getVideoTracks().forEach((track) => track.stop());\n  }\n  if (isMediaStreamTrack(stream)) {\n    stream.stop();\n  }\n}\n\nexport function setVideoSource(\n  video: HTMLVideoElement,\n  stream: MediaStream | MediaSource | Blob | null\n): void {\n  const createObjectURL = window.URL.createObjectURL ?? window.webkitURL.createObjectURL;\n\n  if (typeof video.srcObject !== 'undefined') {\n    video.srcObject = stream;\n  } else if (typeof (video as any).mozSrcObject !== 'undefined') {\n    (video as any).mozSrcObject = stream;\n  } else if (stream && createObjectURL) {\n    video.src = createObjectURL(stream as MediaSource | Blob);\n  }\n\n  if (!stream) {\n    const revokeObjectURL = window.URL.revokeObjectURL ?? window.webkitURL.revokeObjectURL;\n    const source = video.src ?? video.srcObject ?? (video as any).mozSrcObject;\n    if (revokeObjectURL && typeof source === 'string') {\n      revokeObjectURL(source);\n    }\n  }\n}\n\nexport function isCapabilityAvailable(video: HTMLVideoElement, keyName: string): boolean {\n  const stream = video.srcObject;\n\n  if (stream instanceof MediaStream) {\n    const videoTrack = stream.getVideoTracks()[0];\n    return videoTrack.getCapabilities?.()?.[keyName];\n  }\n\n  return false;\n}\n\nfunction isMediaStreamTrack(input: any): input is MediaStreamTrack {\n  return typeof input.stop === 'function';\n}\n\nfunction convertNormalizedSetting(range: MediaSettingsRange, value?: number): number | undefined {\n  if (!value) {\n    return;\n  }\n  // convert the normalized incoming setting to the native camera zoom range\n  const converted = convertRange(value, [range.min, range.max]);\n  // clamp value so we don't get an error\n  return Math.min(range.max, Math.max(range.min, converted));\n}\n\nfunction convertRange(value: number, r2: number[], r1: number[] = [0, 1]): number {\n  return ((value - r1[0]) * (r2[1] - r2[0])) / (r1[1] - r1[0]) + r2[0];\n}\n\nfunction validatedConstrainedValue<T>(props: {\n  constraintKey: string;\n  settingsKey: string;\n  convertedSetting: T;\n  capabilities: MediaTrackCapabilities;\n  settings: WebCameraSettings;\n  cameraType: string;\n}): T | undefined {\n  const { constraintKey, settingsKey, convertedSetting, capabilities, settings, cameraType } =\n    props;\n  const setting = settings[settingsKey];\n  if (\n    Array.isArray(capabilities[constraintKey]) &&\n    convertedSetting &&\n    !capabilities[constraintKey].includes(convertedSetting)\n  ) {\n    if (__DEV__) {\n      // Only warn in dev mode.\n      console.warn(\n        ` { ${settingsKey}: \"${setting}\" } (converted to \"${convertedSetting}\" in the browser) is not supported for camera type \"${cameraType}\" in your browser. Using the default value instead.`\n      );\n    }\n    return undefined;\n  }\n  return convertedSetting;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}